
/**
 * Our sound has gotten a little abrasive. We can add a filter to tone it down.
 *
 * Filters come in different flavours. Here we're adding a low pass filter.
 * This means we're removing high frequencies and letting lower ones pass
 * unchanged.
 *
 * Like an Oscillator, a Filter has a frequency it operates on (sometimes
 * called cutoff). In the case of a low pass, frequencies above this cutoff
 * are removed, and frequencies below it are left unchanged.
 *
 * To make our sound consistent across the keyboard, we'll set the frequency of
 * the filter to be relative to the note frequency.
 */

graph Main  [[ main ]] {
    output stream float out;
    input event std::midi::Message midiIn;

    let NUMBER_OF_VOICES = 8;

    node {
        voices = Voice[8];
        allocator = std::voices::VoiceAllocator(NUMBER_OF_VOICES);
    }

    connection {
        midiIn -> std::midi::MPEConverter -> allocator;
        allocator.voiceEventOut -> voices.eventIn;
        voices -> std::levels::ConstantGain(float, 0.15f) -> out;
    }
}

processor NoteToFrequency {
    input event (std::notes::NoteOn) eventIn;
    output event float frequencyOut;
    
    event eventIn(std::notes::NoteOn e) {
        frequencyOut <- std::notes::noteToFrequency(e.pitch);
    }
}

processor Double {
    input event float in;
    output event float out;

    event in(float x) {
        out <- x * 2.0f;
    }
}

graph Voice {
    output stream float out;
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    
    node {
        oscillator = std::oscillators::PolyblepOscillator(float);
        envelope = std::envelopes::FixedASR(0.1f, 0.1f);
        noteToFrequency = NoteToFrequency;
        filter = std::filters::simper::Processor;
    }

    connection {
        eventIn -> noteToFrequency;
        noteToFrequency -> oscillator.frequencyIn;
        noteToFrequency -> Double -> filter.frequency;
        eventIn -> envelope.eventIn;
        (oscillator.out * envelope.gainOut) -> filter.in;
        filter.out -> out;
    }
}
